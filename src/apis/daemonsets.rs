// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium -f -
// kopium version: 0.15.0

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use std::collections::HashMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug)]
#[kube(group = "apps.kruise.io", version = "v1alpha1", kind = "DaemonSet", plural = "daemonsets")]
#[kube(namespaced)]
#[kube(status = "DaemonSetStatus")]
#[kube(schema = "disabled")]
pub struct DaemonSetSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "burstReplicas")]
    pub burst_replicas: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "revisionHistoryLimit")]
    pub revision_history_limit: Option<i32>,
    pub selector: DaemonSetSelector,
    pub template: HashMap<String, serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateStrategy")]
    pub update_strategy: Option<DaemonSetUpdateStrategy>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct DaemonSetSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<DaemonSetSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct DaemonSetSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct DaemonSetUpdateStrategy {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdate")]
    pub rolling_update: Option<DaemonSetUpdateStrategyRollingUpdate>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct DaemonSetUpdateStrategyRollingUpdate {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub paused: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdateType")]
    pub rolling_update_type: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<DaemonSetUpdateStrategyRollingUpdateSelector>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct DaemonSetUpdateStrategyRollingUpdateSelector {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<DaemonSetUpdateStrategyRollingUpdateSelectorMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct DaemonSetUpdateStrategyRollingUpdateSelectorMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct DaemonSetStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "collisionCount")]
    pub collision_count: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<DaemonSetStatusConditions>>,
    #[serde(rename = "currentNumberScheduled")]
    pub current_number_scheduled: i32,
    #[serde(rename = "daemonSetHash")]
    pub daemon_set_hash: String,
    #[serde(rename = "desiredNumberScheduled")]
    pub desired_number_scheduled: i32,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberAvailable")]
    pub number_available: Option<i32>,
    #[serde(rename = "numberMisscheduled")]
    pub number_misscheduled: i32,
    #[serde(rename = "numberReady")]
    pub number_ready: i32,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "numberUnavailable")]
    pub number_unavailable: Option<i32>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    #[serde(rename = "updatedNumberScheduled")]
    pub updated_number_scheduled: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct DaemonSetStatusConditions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastTransitionTime")]
    pub last_transition_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    pub status: String,
    #[serde(rename = "type")]
    pub r#type: String,
}

