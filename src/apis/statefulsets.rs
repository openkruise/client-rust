// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium -Af -
// kopium version: 0.15.0

use kube::CustomResource;
use schemars::JsonSchema;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use std::collections::HashMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;

/// StatefulSetSpec defines the desired state of StatefulSet
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema)]
#[kube(group = "apps.kruise.io", version = "v1beta1", kind = "StatefulSet", plural = "statefulsets")]
#[kube(namespaced)]
#[kube(status = "StatefulSetStatus")]
pub struct StatefulSetSpec {
    /// Lifecycle defines the lifecycle hooks for Pods pre-delete, in-place update.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub lifecycle: Option<StatefulSetLifecycle>,
    /// PersistentVolumeClaimRetentionPolicy describes the policy used for PVCs created from the StatefulSet VolumeClaimTemplates. This requires the StatefulSetAutoDeletePVC feature gate to be enabled, which is alpha.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "persistentVolumeClaimRetentionPolicy")]
    pub persistent_volume_claim_retention_policy: Option<StatefulSetPersistentVolumeClaimRetentionPolicy>,
    /// podManagementPolicy controls how pods are created during initial scale up, when replacing pods on nodes, or when scaling down. The default policy is `OrderedReady`, where pods are created in increasing order (pod-0, then pod-1, etc) and the controller will wait until each pod is ready before continuing. When scaling down, the pods are removed in the opposite order. The alternative policy is `Parallel` which will create pods in parallel to match the desired scale without waiting, and on scale down will delete all pods at once.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podManagementPolicy")]
    pub pod_management_policy: Option<String>,
    /// replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1. TODO: Consider a rename of this field.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// reserveOrdinals controls the ordinal numbers that should be reserved, and the replicas will always be the expectation number of running Pods. For a sts with replicas=3 and its Pods in [0, 1, 2]: - If you want to migrate Pod-1 and reserve this ordinal, just set spec.reserveOrdinal to [1]. Then controller will delete Pod-1 and create Pod-3 (existing Pods will be [0, 2, 3]) - If you just want to delete Pod-1, you should set spec.reserveOrdinal to [1] and spec.replicas to 2. Then controller will delete Pod-1 (existing Pods will be [0, 2])
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "reserveOrdinals")]
    pub reserve_ordinals: Option<Vec<i64>>,
    /// revisionHistoryLimit is the maximum number of revisions that will be maintained in the StatefulSet's revision history. The revision history consists of all revisions not represented by a currently applied StatefulSetSpec version. The default value is 10.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "revisionHistoryLimit")]
    pub revision_history_limit: Option<i32>,
    /// scaleStrategy indicates the StatefulSetScaleStrategy that will be employed to scale Pods in the StatefulSet.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scaleStrategy")]
    pub scale_strategy: Option<StatefulSetScaleStrategy>,
    /// selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
    pub selector: StatefulSetSelector,
    /// serviceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is managed by the StatefulSet controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceName")]
    pub service_name: Option<String>,
    /// template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.
    pub template: HashMap<String, serde_json::Value>,
    /// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateStrategy")]
    pub update_strategy: Option<StatefulSetUpdateStrategy>,
    /// volumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name. TODO: Define the behavior if a claim already exists with the same name.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeClaimTemplates")]
    pub volume_claim_templates: Option<HashMap<String, serde_json::Value>>,
}

/// Lifecycle defines the lifecycle hooks for Pods pre-delete, in-place update.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetLifecycle {
    /// InPlaceUpdate is the hook before Pod to update and after Pod has been updated.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inPlaceUpdate")]
    pub in_place_update: Option<StatefulSetLifecycleInPlaceUpdate>,
    /// PreDelete is the hook before Pod to be deleted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preDelete")]
    pub pre_delete: Option<StatefulSetLifecyclePreDelete>,
    /// PreNormal is the hook after Pod to be created and ready to be Normal.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preNormal")]
    pub pre_normal: Option<StatefulSetLifecyclePreNormal>,
}

/// InPlaceUpdate is the hook before Pod to update and after Pod has been updated.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetLifecycleInPlaceUpdate {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finalizersHandler")]
    pub finalizers_handler: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelsHandler")]
    pub labels_handler: Option<BTreeMap<String, String>>,
    /// MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "markPodNotReady")]
    pub mark_pod_not_ready: Option<bool>,
}

/// PreDelete is the hook before Pod to be deleted.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetLifecyclePreDelete {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finalizersHandler")]
    pub finalizers_handler: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelsHandler")]
    pub labels_handler: Option<BTreeMap<String, String>>,
    /// MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "markPodNotReady")]
    pub mark_pod_not_ready: Option<bool>,
}

/// PreNormal is the hook after Pod to be created and ready to be Normal.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetLifecyclePreNormal {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finalizersHandler")]
    pub finalizers_handler: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelsHandler")]
    pub labels_handler: Option<BTreeMap<String, String>>,
    /// MarkPodNotReady = true means: - Pod will be set to 'NotReady' at preparingDelete/preparingUpdate state. - Pod will be restored to 'Ready' at Updated state if it was set to 'NotReady' at preparingUpdate state. Currently, MarkPodNotReady only takes effect on InPlaceUpdate & PreDelete hook. Default to false.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "markPodNotReady")]
    pub mark_pod_not_ready: Option<bool>,
}

/// PersistentVolumeClaimRetentionPolicy describes the policy used for PVCs created from the StatefulSet VolumeClaimTemplates. This requires the StatefulSetAutoDeletePVC feature gate to be enabled, which is alpha.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetPersistentVolumeClaimRetentionPolicy {
    /// WhenDeleted specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is deleted. The default policy of `Retain` causes PVCs to not be affected by StatefulSet deletion. The `Delete` policy causes those PVCs to be deleted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "whenDeleted")]
    pub when_deleted: Option<String>,
    /// WhenScaled specifies what happens to PVCs created from StatefulSet VolumeClaimTemplates when the StatefulSet is scaled down. The default policy of `Retain` causes PVCs to not be affected by a scaledown. The `Delete` policy causes the associated PVCs for any excess pods above the replica count to be deleted.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "whenScaled")]
    pub when_scaled: Option<String>,
}

/// scaleStrategy indicates the StatefulSetScaleStrategy that will be employed to scale Pods in the StatefulSet.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetScaleStrategy {
    /// The maximum number of pods that can be unavailable during scaling. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. It can just be allowed to work with Parallel podManagementPolicy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
}

/// selector is a label query over pods that should match the replica count. It must match the pod template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<StatefulSetSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// updateStrategy indicates the StatefulSetUpdateStrategy that will be employed to update Pods in the StatefulSet when a revision is made to Template.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetUpdateStrategy {
    /// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdate")]
    pub rolling_update: Option<StatefulSetUpdateStrategyRollingUpdate>,
    /// Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<String>,
}

/// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetUpdateStrategyRollingUpdate {
    /// InPlaceUpdateStrategy contains strategies for in-place update.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "inPlaceUpdateStrategy")]
    pub in_place_update_strategy: Option<StatefulSetUpdateStrategyRollingUpdateInPlaceUpdateStrategy>,
    /// The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. Also, maxUnavailable can just be allowed to work with Parallel podManagementPolicy. Defaults to 1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
    /// MinReadySeconds indicates how long will the pod be considered ready after it's updated. MinReadySeconds works with both OrderedReady and Parallel podManagementPolicy. It affects the pod scale up speed when the podManagementPolicy is set to be OrderedReady. Combined with MaxUnavailable, it affects the pod update speed regardless of podManagementPolicy. Default value is 0, max is 300.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i32>,
    /// Partition indicates the ordinal at which the StatefulSet should be partitioned by default. But if unorderedUpdate has been set: - Partition indicates the number of pods with non-updated revisions when rolling update. - It means controller will update $(replicas - partition) number of pod. Default value is 0.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<i32>,
    /// Paused indicates that the StatefulSet is paused. Default value is false
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub paused: Option<bool>,
    /// PodUpdatePolicy indicates how pods should be updated Default value is "ReCreate"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podUpdatePolicy")]
    pub pod_update_policy: Option<String>,
    /// UnorderedUpdate contains strategies for non-ordered update. If it is not nil, pods will be updated with non-ordered sequence. Noted that UnorderedUpdate can only be allowed to work with Parallel podManagementPolicy
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unorderedUpdate")]
    pub unordered_update: Option<StatefulSetUpdateStrategyRollingUpdateUnorderedUpdate>,
}

/// InPlaceUpdateStrategy contains strategies for in-place update.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetUpdateStrategyRollingUpdateInPlaceUpdateStrategy {
    /// GracePeriodSeconds is the timespan between set Pod status to not-ready and update images in Pod spec when in-place update a Pod.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "gracePeriodSeconds")]
    pub grace_period_seconds: Option<i32>,
}

/// UnorderedUpdate contains strategies for non-ordered update. If it is not nil, pods will be updated with non-ordered sequence. Noted that UnorderedUpdate can only be allowed to work with Parallel podManagementPolicy
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetUpdateStrategyRollingUpdateUnorderedUpdate {
    /// Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "priorityStrategy")]
    pub priority_strategy: Option<StatefulSetUpdateStrategyRollingUpdateUnorderedUpdatePriorityStrategy>,
}

/// Priorities are the rules for calculating the priority of updating pods. Each pod to be updated, will pass through these terms and get a sum of weights.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetUpdateStrategyRollingUpdateUnorderedUpdatePriorityStrategy {
    /// Order priority terms, pods will be sorted by the value of orderedKey. For example: ``` orderPriority: - orderedKey: key1 - orderedKey: key2 ``` First, all pods which have key1 in labels will be sorted by the value of key1. Then, the left pods which have no key1 but have key2 in labels will be sorted by the value of key2 and put behind those pods have key1.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "orderPriority")]
    pub order_priority: Option<Vec<StatefulSetUpdateStrategyRollingUpdateUnorderedUpdatePriorityStrategyOrderPriority>>,
    /// Weight priority terms, pods will be sorted by the sum of all terms weight.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "weightPriority")]
    pub weight_priority: Option<Vec<StatefulSetUpdateStrategyRollingUpdateUnorderedUpdatePriorityStrategyWeightPriority>>,
}

/// UpdatePriorityOrderTerm defines order priority.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetUpdateStrategyRollingUpdateUnorderedUpdatePriorityStrategyOrderPriority {
    /// Calculate priority by value of this key. Values of this key, will be sorted by GetInt(val). GetInt method will find the last int in value, such as getting 5 in value '5', getting 10 in value 'sts-10'.
    #[serde(rename = "orderedKey")]
    pub ordered_key: String,
}

/// UpdatePriorityWeightTerm defines weight priority.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetUpdateStrategyRollingUpdateUnorderedUpdatePriorityStrategyWeightPriority {
    /// MatchSelector is used to select by pod's labels.
    #[serde(rename = "matchSelector")]
    pub match_selector: StatefulSetUpdateStrategyRollingUpdateUnorderedUpdatePriorityStrategyWeightPriorityMatchSelector,
    /// Weight associated with matching the corresponding matchExpressions, in the range 1-100.
    pub weight: i32,
}

/// MatchSelector is used to select by pod's labels.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetUpdateStrategyRollingUpdateUnorderedUpdatePriorityStrategyWeightPriorityMatchSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<StatefulSetUpdateStrategyRollingUpdateUnorderedUpdatePriorityStrategyWeightPriorityMatchSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetUpdateStrategyRollingUpdateUnorderedUpdatePriorityStrategyWeightPriorityMatchSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// StatefulSetStatus defines the observed state of StatefulSet
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetStatus {
    /// AvailableReplicas is the number of Pods created by the StatefulSet controller that have been ready for minReadySeconds.
    #[serde(rename = "availableReplicas")]
    pub available_replicas: i32,
    /// collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "collisionCount")]
    pub collision_count: Option<i32>,
    /// Represents the latest available observations of a statefulset's current state.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<StatefulSetStatusConditions>>,
    /// currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by currentRevision.
    #[serde(rename = "currentReplicas")]
    pub current_replicas: i32,
    /// currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [0,currentReplicas).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "currentRevision")]
    pub current_revision: Option<String>,
    /// LabelSelector is label selectors for query over pods that should match the replica count used by HPA.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "labelSelector")]
    pub label_selector: Option<String>,
    /// observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the StatefulSet's generation, which is updated on mutation by the API Server.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// readyReplicas is the number of Pods created by the StatefulSet controller that have a Ready Condition.
    #[serde(rename = "readyReplicas")]
    pub ready_replicas: i32,
    /// replicas is the number of Pods created by the StatefulSet controller.
    pub replicas: i32,
    /// updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence [replicas-updatedReplicas,replicas)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updateRevision")]
    pub update_revision: Option<String>,
    /// updatedAvailableReplicas is the number of updated Pods created by the StatefulSet controller that have a Ready condition for atleast minReadySeconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedAvailableReplicas")]
    pub updated_available_replicas: Option<i32>,
    /// updatedReadyReplicas is the number of updated Pods created by the StatefulSet controller that have a Ready Condition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedReadyReplicas")]
    pub updated_ready_replicas: Option<i32>,
    /// updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version indicated by updateRevision.
    #[serde(rename = "updatedReplicas")]
    pub updated_replicas: i32,
}

/// StatefulSetCondition describes the state of a statefulset at a certain point.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct StatefulSetStatusConditions {
    /// Last time the condition transitioned from one status to another.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastTransitionTime")]
    pub last_transition_time: Option<String>,
    /// A human readable message indicating details about the transition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// The reason for the condition's last transition.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    /// Status of the condition, one of True, False, Unknown.
    pub status: String,
    /// Type of statefulset condition.
    #[serde(rename = "type")]
    pub r#type: String,
}

